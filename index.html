<!DOCTYPE html>
<html>
<head>
<title>Emoji-Dash</title>
    <h4>Made by Luke Linton, follow me on <a href="https://x.com/LukeEMLinton79" target="_blank">X (Twitter)</a>  
  for updates on coding, tech, and creativity!<h4>
<style>
body { margin:0; overflow:hidden; font-family:Arial; }
canvas { display:block; }

/* HUD with liquid-glass style */
#hud {
    position:absolute;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:40px;
    align-items:center;
}
#hud div {
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(8px);
    border-radius:15px;
    padding:10px 20px;
    color:white;
    font-size:28px;
    text-shadow:0 0 4px #000;
}

/* Leaderboard */
#leaderboard {
    position:absolute;
    top:140px;
    right:20px;
    color:white;
    font-size:20px;
    text-align:right;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(8px);
    border-radius:12px;
    padding:10px;
}

/* Messages */
#msg { position:absolute; top:45%; width:100%; text-align:center; color:white; font-size:40px; display:none; cursor:pointer; text-shadow:0 0 6px #000; }

/* Home Menu */
#menu {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background: linear-gradient(135deg,#0a0f2d,#220033);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
}
#menu h1 { color:white; font-size:64px; margin-bottom:20px; text-align:center; text-shadow:0 0 12px #ff0; }
#menu button {
    font-size:24px; padding:10px 24px; border-radius:20px; cursor:pointer; border:none;
    margin:5px; background: rgba(255,255,255,0.2); color:white; backdrop-filter: blur(6px);
    transition: transform 0.2s, background 0.2s;
}
#menu button:hover { transform:scale(1.1); background: rgba(255,255,255,0.35); }

/* Skin & Background selectors */
#skins, #backgrounds { display:flex; flex-wrap:wrap; justify-content:center; margin-bottom:10px; gap:10px; }
</style>
</head>
<body>

<!-- Menu -->
<div id="menu">
    <h1>Emoji-Dash</h1>
    <div id="skins">Choose Skin:</div>
    <div id="backgrounds">Choose Background:</div>
    <button id="startBtn">Play</button>
</div>

<!-- HUD -->
<div id="hud">
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <div id="level">Level: 1</div>
</div>

<div id="leaderboard">Leaderboard:<br></div>
<div id="msg">Game Over! Click to Restart</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// PLAYER SKINS & BACKGROUNDS
const playerSkins = ["ðŸ˜Ž","ðŸ˜","ðŸ˜‡","ðŸ¤©","ðŸ¥³","ðŸ˜œ","ðŸ˜","ðŸ¤–","ðŸ˜’","ðŸ±","ðŸ˜‰","ðŸ˜Š"];
let selectedSkin = playerSkins[0];
const backgrounds = [
    {name:"Night Sky", color:"#0a0f2d"},
    {name:"Sunset", color:"#ff7e5f"},
    {name:"Rainbow", color:"gradient"},
    {name:"Deep Space", color:"#220033"},
    {name:"Blue Sky", color:"#87ceeb"}
];
let selectedBackground = backgrounds[0];

// MENU SETUP
const skinDiv = document.getElementById("skins");
playerSkins.forEach(skin=>{
    const btn = document.createElement("button"); btn.innerText=skin; btn.onclick=()=>{selectedSkin=skin;};
    skinDiv.appendChild(btn);
});
const bgDiv = document.getElementById("backgrounds");
backgrounds.forEach(bg=>{
    const btn = document.createElement("button"); btn.innerText=bg.name; btn.onclick=()=>{selectedBackground=bg;};
    bgDiv.appendChild(btn);
});

// GAME VARIABLES
let player={x:150, y:canvas.height-150, size:50, vy:0, gravity:1, jumpPower:-20, onGround:true, doubleJump:true, dash:false, dashSpeed:0, sprite:selectedSkin, trail:[]};
let obstacles=[], stars=[], enemies=[], loops=[], particles=[];
let gameSpeed=8, score=0, multiplier=1, gameOver=false, gameStarted=false, paused=false;
let lives=3, currentLevel=1;

// LOCALSTORAGE LEADERBOARD
let leaderboard = JSON.parse(localStorage.getItem("smileyLeaderboard")) || [];
function updateLeaderboardDisplay(){
    let lbDiv = document.getElementById("leaderboard");
    lbDiv.innerHTML="Leaderboard:<br>";
    leaderboard.sort((a,b)=>b-a).slice(0,5).forEach((s,i)=>{ lbDiv.innerHTML += `${i+1}. ${s}<br>`; });
}
updateLeaderboardDisplay();

// BACKGROUND STARS
let bgStars=[], midStars=[], fgStars=[];
for(let i=0;i<50;i++){ bgStars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*1.5+0.5, speed:0.2}); }
for(let i=0;i<30;i++){ midStars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*2+1, speed:0.5}); }
for(let i=0;i<20;i++){ fgStars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*3+1, speed:1}); }

// HELPER FUNCTIONS
function spawnObstacle(){ obstacles.push({x:canvas.width+50,y:canvas.height-130,size:50,sprite:"ðŸŒ•"}); }
function spawnStar(){ stars.push({x:canvas.width+50,y:canvas.height-200-Math.random()*150,size:40,sprite:"â­"}); }
function spawnEnemy(){ enemies.push({x:canvas.width+50,y:canvas.height-130,size:50,dir:Math.random()<0.5?1:-1,sprite:"ðŸ˜ˆ"}); }
function spawnLoop(){ loops.push({x:canvas.width+50,y:canvas.height-150,radius:40,color:randomColor()}); }
function randomColor(){ const colors=["#0ff","#f0f","#ff0","#0f0","#f00","#0f8"]; return colors[Math.floor(Math.random()*colors.length)]; }
function addParticle(x,y,color){ particles.push({x,y,vx:(Math.random()-0.5)*4,vy:(Math.random()-1.5)*4,size:Math.random()*6+2,color,life:30}); }
function drawStars(array){ for(let s of array){ s.x -= s.speed; if(s.x<0) s.x=canvas.width; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(s.x,s.y,s.size,0,Math.PI*2); ctx.fill(); } }

// LEVEL AND LIVES
function nextLevel(){ currentLevel++; if(currentLevel>3){ endGame(true); return; } gameSpeed+=2; document.getElementById("level").innerText="Level: "+currentLevel; }
function loseLife(){ lives--; document.getElementById("lives").innerText="Lives: "+lives; if(lives<=0) endGame(); }

// UPDATE LOOP
function update(){
    if(!gameStarted || paused) return;

    // Background
    if(selectedBackground.color=="gradient"){
        let grad = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
        grad.addColorStop(0,"red"); grad.addColorStop(0.2,"orange"); grad.addColorStop(0.4,"yellow");
        grad.addColorStop(0.6,"green"); grad.addColorStop(0.8,"blue"); grad.addColorStop(1,"violet");
        ctx.fillStyle=grad;
    } else { ctx.fillStyle=selectedBackground.color; }
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawStars(bgStars); drawStars(midStars); drawStars(fgStars);

    player.dashSpeed=player.dash?15:0;

    // Player physics
    player.vy += player.gravity;
    player.y += player.vy;
    if(player.y>canvas.height-150){player.y=canvas.height-150; player.vy=0; player.onGround=true; player.doubleJump=true;}

    // Dash trail
    if(player.dash){ player.trail.push({x:player.x,y:player.y,life:10}); }
    for(let t of player.trail){ ctx.font=player.size+"px Arial"; ctx.globalAlpha=t.life/10; ctx.fillText(player.sprite,t.x,t.y); t.life--; }
    player.trail = player.trail.filter(t=>t.life>0);
    ctx.globalAlpha=1;

    ctx.font=player.size+"px Arial"; ctx.fillText(player.sprite,player.x,player.y);

    // Obstacles
    for(let o of obstacles){ o.x -= gameSpeed+player.dashSpeed; ctx.font=o.size+"px Arial"; ctx.fillText(o.sprite,o.x,o.y); 
        if(player.x<o.x+o.size && player.x+player.size>o.x && player.y+player.size>o.y && player.y<o.y+o.size){ 
            obstacles.splice(obstacles.indexOf(o),1); loseLife(); } }
    obstacles=obstacles.filter(o=>o.x>-100);

    // Stars
    for(let s of stars){ s.x -= gameSpeed+player.dashSpeed; s.y += Math.sin(Date.now()/200+s.x/50)*2; ctx.font=s.size+"px Arial"; ctx.fillText(s.sprite,s.x,s.y);
        if(Math.random()<0.05) addParticle(s.x,s.y,"#fff");
        if(player.x<s.x+s.size && player.x+player.size>s.x && player.y<s.y+s.size && player.y+player.size>s.y){ score+=10*multiplier; multiplier=2; stars.splice(stars.indexOf(s),1); for(let i=0;i<5;i++) addParticle(s.x,s.y,"#ff0"); } }
    stars=stars.filter(s=>s.x>-100);

    // Enemies
    for(let e of enemies){ e.x -= gameSpeed+player.dashSpeed; e.x+=e.dir*2; e.y+=Math.sin(Date.now()/300 + e.x/50)*2; if(Math.random()<0.01) e.dir*=-1;
        ctx.font=e.size+"px Arial"; ctx.fillText(e.sprite,e.x,e.y);
        if(player.x<e.x+e.size && player.x+player.size>e.x && player.y+player.size>e.y && player.y<e.y+e.size){ enemies.splice(enemies.indexOf(e),1); loseLife(); } }
    enemies=enemies.filter(e=>e.x>-100);

    // Loops
    for(let l of loops){ l.x-=gameSpeed+player.dashSpeed; ctx.beginPath(); ctx.strokeStyle=l.color; ctx.lineWidth=4; ctx.arc(l.x,l.y,l.radius,0,Math.PI*2); ctx.stroke();
        if(player.x<l.x+l.radius && player.x+player.size>l.x-l.radius && player.y<l.y+l.radius && player.y+player.size>l.y-l.radius){ player.vy=player.jumpPower/2; addParticle(player.x,player.y,l.color); } }
    loops=loops.filter(l=>l.x>-100);

    // Particles
    for(let p of particles){ p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillStyle=p.color; ctx.globalAlpha=p.life/30; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
    particles=particles.filter(p=>p.life>0); ctx.globalAlpha=1;

    score++; document.getElementById("score").innerText="Score: "+score;
    if(multiplier>1) multiplier-=0.01;
    gameSpeed+=0.001;

    // Level progression
    if(currentLevel==1 && score>=500) nextLevel();
    if(currentLevel==2 && score>=1000) nextLevel();

    requestAnimationFrame(update);
}

// END GAME
function endGame(won=false){
    gameOver=true;
    document.getElementById("msg").innerText=won?"You Won! Click to Restart":"Game Over! Click to Restart";
    document.getElementById("msg").style.display="block";
    leaderboard.push(score);
    localStorage.setItem("smileyLeaderboard",JSON.stringify(leaderboard));
    updateLeaderboardDisplay();
    stopSpawning();
}

// SPAWN INTERVALS
let spawnIntervals=[];
function startSpawning(){ spawnIntervals.push(setInterval(spawnObstacle,2000)); spawnIntervals.push(setInterval(spawnStar,1500)); spawnIntervals.push(setInterval(spawnEnemy,3000)); spawnIntervals.push(setInterval(spawnLoop,5000)); }
function stopSpawning(){ spawnIntervals.forEach(i=>clearInterval(i)); spawnIntervals=[]; }

// CONTROLS
document.addEventListener("keydown",(e)=>{
    if(!gameStarted || paused) return;
    if(e.code==="Space"){ if(gameOver) location.reload();
        if(player.onGround){ player.vy=player.jumpPower; player.onGround=false; } else if(player.doubleJump){ player.vy=player.jumpPower; player.doubleJump=false; }
        for(let i=0;i<5;i++) addParticle(player.x,player.y,"#0ff");
    }
    if(e.code==="ShiftLeft") player.dash=true;
    if(e.code==="KeyP") paused=!paused;
});
document.addEventListener("keyup",(e)=>{ if(e.code==="ShiftLeft") player.dash=false; });

// HOME SCREEN
document.getElementById("startBtn").addEventListener("click",()=>{
    player.sprite = selectedSkin;
    document.getElementById("menu").style.display="none";
    gameStarted=true; startSpawning(); update();
});
document.getElementById("msg").addEventListener("click",()=>{ location.reload(); });
</script>
</body>
</html>



